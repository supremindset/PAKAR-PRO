<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PAKAR QIBLAT</title>
  <link rel="canonical" href="https://supremindset.github.io/PAKAR-PRO/" />
  <link rel="manifest" href="/PAKAR-PRO/manifest.json">
  <script>
    if (navigator.serviceWorker) {
      navigator.serviceWorker.register(
        '/PAKAR-PRO/sw.js',
        {scope: '/PAKAR-PRO/'}
      )
    }
  </script>
  <style>
    body {
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #f7f9fc;
    }

    h2 {
      color: #34495e;
      margin-bottom: 20px;
    }

    .container {
      height: auto;
      min-height: 100vh;
      overflow-y: auto; /* Ensure the container can scroll */
      width: 100%;
      position: relative;
      padding-top: 30px;
    }

    .circle-container {
  position: relative;
  width: 300px;
  height: 300px;
  margin-bottom: 50px;
  background-color: #ffffff;
  border-radius: 50%;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  z-index: 1;
}

.circle {
	position: absolute;
	top: 0;
	width: 100%;
	height: 100%;
	border-radius: 50%;
	border: 1px solid #2980b9;
	transition: transform 0.5s ease;
	background-color: #ffffff;
	z-index: 1;
}
    
    .sticky-wrapper {
      position: relative;
      top: 0;
      z-index: 1000;
      width: 100%;
      display: flex;
      justify-content: center;
      background-color: #f7f9fc;
    }

    .non-sticky {
      position: static; /* Changes from sticky to static */
    }

    .data-inputs {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px; /* Add some margin to prevent overlap with other elements */
    }
    
    .degree-number {
      position: absolute;
      transform-origin: center;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: #2980b9;
    }

    .center-dot {
      position: absolute;
      width: 30px;
      height: 30px;
      background-color: #2980b9;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      border: 2px solid #ffffff;
      transition: background-color 0.3s, transform 0.3s, box-shadow 0.3s;
      z-index: 8; /* Higher z-index to place it on top of lines */
    }

    .center-dot:hover {
      background-color: #3498db;
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.3), 0 6px 12px rgba(0, 0, 0, 0.3);
    }

    .center-dot:active {
      background-color: #1e6a8d;
      transform: translate(-50%, -50%) scale(0.95);
    }

    .center-line {
      position: absolute;
      width: 100%;
      height: 4px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure lines are behind the center-dot */
    }

    .arrow-line {
      position: absolute;
      width: 100%;
      height: 4px;
      background-color: red;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%) rotate(0deg);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure lines are behind the center-dot */
    }

    .short-horizontal-line {
      position: absolute;
      width: 250px;
      height: 2px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .vertical-line {
      position: absolute;
      width: 2px;
      height: 250px;
      background-color: #2980b9;
      top: 50%;
      left: 50%;
      transform-origin: center;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
    }

    .label-west, .label-east {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: -20px 0;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north, .label-south {
      color: #2980b9;
      font-size: 14px;
      font-weight: bold;
      margin: 0 5px;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .label-north {
      margin-left: -20px;
    }

    .label-south {
      margin-right: -20px;
    }

    .label-east {
      margin-bottom: -20px;
    }

    .label-west {
      margin-top: -20px;
    }

    .arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: red;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure heads are behind the center-dot */
    }

    .black-arrow-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background-color: #333;
      top: 50%;
      left: 0;
      transform-origin: center;
      transform: translateY(-50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure lines are behind the center-dot */
    }

    .black-arrow-head {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      top: 50%;
      left: 100%;
      transform: translate(-100%, -50%);
      transition: transform 0.5s ease;
      z-index: 2; /* Ensure heads are behind the center-dot */
    }

    .custom-select {
      box-sizing: border-box;
      width: 300px;
      height: 41px;
      padding: 10px;
      font-size: 14px;
      text-align: center;
      margin: 5px 0; /* Slightly larger margin for better spacing */
      border: 2px solid #2980b9;
      border-radius: 5px;
      outline: none;
      transition: border-color 0.3s;
      background-color: #ffffff;
      cursor: pointer;
    }

    select {
      background-color: #ffffff;
      cursor: pointer;
    }

    input[type="number"]::placeholder {
      color: #7f8c8d;
      font-size: 14px;
      opacity: 0.7;
    }

    input[type="number"]:focus, select:focus {
      border-color: #3498db;
    }

    select::-ms-expand {
      display: none;
    }
    
    .all-fieldset {
      border: 2px solid #2980b9;
      border-radius: 5px;
      padding: 10px;
      margin: 20px 0;
      width: 100%;
      box-sizing: border-box;
    }

    .data-inputs-fieldset {
      border: 2px solid #2980b9;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0;
      width: 100vw;
    }

    .location-btn {
      margin-top: 10px;
      padding: 10px 20px;
      background-color: #2980b9;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .location-btn:hover {
      background-color: #3498db;
    }

    .map-fieldset {
      border: 2px solid #2980b9;
      border-radius: 5px;
      padding: 10px;
      margin: 20px 0;
      width: 100%;
      box-sizing: border-box;
    }

    .map-fieldset legend {
      font-size: 1.2em;
      color: #2980b9;
      font-weight: bold;
      padding: 0 10px;
    }

    #map.circle-map {
      border-radius: 50%; /* Ensure circular shape */
      overflow: hidden; /* Hide overflow */
      transition: all 0.3s ease; /* Smooth transition for resizing */
    }

    #map {
  position: relative;
  height: 50vh; /* Adjust the height as needed */
  width: 100vw; /* Full width of the viewport */
  margin-top: 0;
  border: none;
  transition: all 0.3s ease;
  z-index: 8;
}

    input[type="range"] {
      width: 100%;
      margin: 10px 0;
    }

    .leaflet-control {
      top: 100px;
    }
    
    .red-text {
  color: #1e6a8d;
}

.yellow-text {
  color: #1e6a8d;
}

.firstPin-shadow {
  filter: drop-shadow(0 0 100000px rgba(0, 255, 0, 0.5));
}

.install-banner {
  width: 100vw;
  background-color: #2980b9;
  color: white;
  font-size: 18px;
  font-weight: bold;
  padding: 10px;
  white-space: nowrap;
  overflow: hidden;
  border-radius: 5px;
}


.degree-button-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 20px auto;
}

.degree-button {
    width: 40px;
    height: 40px;
    font-size: 18px;
    margin: 0 10px;
    background-color: #2980b9;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.degree-button:hover {
    background-color: #3498db;
}

.degree-button:active {
    background-color: #1e6a8d;
}

.svg {
  position: absolute;
  top: 1px;
  left: 1px;
  width: 100%;
  height: 100%;
  z-index: 7;
}

.svg text {
    font-size: 10px; /* Adjust the size as needed */
    fill: #333;
}

.arah-qiblat {
      position: absolute;
      top: 60%; /* Move it further down below the red line */
      left: 95%; /* Center it horizontally relative to the line */
      transform: translate(-50%, 0); /* Adjust vertical positioning */
      font-size: 16px;
      color: #333;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .round-button {
  position: absolute;
  top: -50px; /* Adjust this value to position it above the firstPin */
  left: 50%;
  transform: translateX(-50%);
  width: 32px;
  height: 32px;
  background-color: #2980b9;
  color: white;
  border: none;
  border-radius: 50%;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: background-color 0.3s, transform 0.3s;
  z-index: 1001; /* Ensure it's above other elements */
}

.round-button:hover {
  background-color: #3498db;
}

.round-button:active {
  background-color: #1e6a8d;
}

  </style>
</head>
<body>
  <div id="install-banner-container">
  <marquee behavior="scroll" direction="left" scrollamount="5" class="install-banner">
    Semoga Berjaya
  </marquee>
</div>
<fieldset class="data-inputs-fieldset">
      <legend>Qiblat Settings</legend>
      
      <div class="data-inputs">
        
        
        <select class="custom-select" id="kaedahQiblat">
          <option value="bayang" selected>Bayang-Bayang</option>
          <option value="bangunan">Bearing Bangunan</option>
        </select>
        
          <input class="custom-select" type="number" id="degreeInput" placeholder="Sun Azimuth / Bearing Bangunan" min="0" max="360" step="0.1">
          
        
          <input class="custom-select" type="number" id="qiblatInput" placeholder="Qiblat" min="0" max="360" step="0.1">
        
          <input class="custom-select" type="datetime-local" id="dateTimeInput" placeholder="Select Date and Time">
          
          <button id="toggleMapCircle" class="location-btn">Fit Map to Circle</button>
          
      </div>
    </fieldset>
</br>
  <div class="container">
    <div class="sticky-wrapper">
      <div class="circle-container">
        <svg class="svg" width="200" height="200" viewBox="0 0 200 200">
    <path id="sector1" fill="rgba(41, 128, 185, 0.2)"></path> <!-- #2980b9 with transparency -->
    <path id="sector2" fill="rgba(214, 234, 248, 0.5)"></path> <!-- Light blue with transparency -->
    <path id="sector3" fill="rgba(41, 128, 185, 0.2)"></path> <!-- #2980b9 with transparency -->
    <path id="sector4" fill="rgba(214, 234, 248, 0.5)"></path> <!-- Light blue with transparency -->
    <text id="label1" x="0" y="0" text-anchor="middle"></text>
    <text id="label2" x="0" y="0" text-anchor="middle"></text>
    <text id="label3" x="0" y="0" text-anchor="middle"></text>
    <text id="label4" x="0" y="0" text-anchor="middle"></text>
</svg>
<button class="center-dot" id="centerDotButton"></button>
        <div class="circle" id="circle">
          
          
          <div class="center-line" id="centerLine"></div>
          <div class="arrow-line" id="arrowLine">
            <div class="arrow-head" id="arrowHead"></div>
            <div class="arah-qiblat">
  <span class="qiblat-arrow">🕋</span>
</div>
          </div>
          <div class="black-arrow-line" id="blackArrowLine">
            <div class="black-arrow-head" id="blackArrowHead"></div>
          </div>
          <div class="short-horizontal-line" id="shortHorizontalLine">
            <div class="label-north">N</div>
            <div class="label-south">S</div>
          </div>
          <div class="vertical-line" id="verticalLine">
            <div class="label-east">E</div>
            <div class="label-west">W</div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="degree-button-container">
    <button class="degree-button" id="decreaseButton">–</button>
    <span id="rotationValue">0°</span>
    <button class="degree-button" id="increaseButton">+</button>
</div>

      
      <div id="install-banner-container"></div>
    
    <fieldset class="map-fieldset">
      <legend><button id="updateLocationButton" class="location-btn">Update Location</button></legend>
      <div id="map" style="position: relative; height: 50vh; width: 100%; margin-top: 0; border: none;"></div>
    </fieldset>

    <div id="markerTooltipContainer" style="padding: 10px; background-color: #f7f9fc; border-top: 1px solid #2980b9;">
  <p>
    <span class="red-text" id="markerTooltipText1"></span>
    <span class="yellow-text" id="markerTooltipText2"></span>
  </p>
</div>

  </div>
<script>
function isOnline() {
  return navigator.onLine;
}

function loadScript(url, callback) {
  const script = document.createElement('script');
  script.src = url;
  script.defer = true;
  script.onload = callback;
  document.body.appendChild(script);
}

let updateBearingAndLines;
let mapInitialized = false;
let activityTimeout;
let inputDebounceTimeout;
let degree = 0;
let holdInterval = null;
let speed = 1000;
let firstPin, secondPin;

window.onload = function() {
  if (isOnline()) {
    initializeMapIfOnline();
  } else {
    document.getElementById('map').style.display = 'none';
  }

  const circleWrapper = document.querySelector('.sticky-wrapper');
  toggleStickyOnFocus(ELEMENTS.degreeInput, circleWrapper);
  toggleStickyOnFocus(ELEMENTS.qiblatInput, circleWrapper);

  setupInputWithDebounce(ELEMENTS.degreeInput);
  setupInputWithDebounce(ELEMENTS.qiblatInput);

  const toggleMapCircleButton = document.getElementById('toggleMapCircle');
  toggleMapCircleButton.addEventListener('click', toggleMapCircle);

  initializeDegreeButtons();
  populateDegreeNumbers();
  initializeDynamicAngleUpdates();
};

function initializeMapIfOnline() {
  if (!mapInitialized) {
    loadLeafletResources(function() {
      initializeMap();
      mapInitialized = true;
    });
  }
}

function loadLeafletResources(callback) {
  const leafletCSS = document.createElement('link');
  leafletCSS.rel = 'stylesheet';
  leafletCSS.href = 'https://unpkg.com/leaflet/dist/leaflet.css';
  document.head.appendChild(leafletCSS);

  const geocoderCSS = document.createElement('link');
  geocoderCSS.rel = 'stylesheet';
  geocoderCSS.href = 'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css';
  document.head.appendChild(geocoderCSS);

  loadScript('https://unpkg.com/leaflet/dist/leaflet.js', function() {
    loadScript('https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js', function() {
      loadScript('https://unpkg.com/suncalc/suncalc.js', callback);
    });
  });
}

function checkNetworkStatus() {
  if (navigator.onLine) {
    document.getElementById('map').style.display = 'block';
    initializeMapIfOnline();
  } else {
    document.getElementById('map').style.display = 'none';
  }
}

window.addEventListener('online', checkNetworkStatus);
window.addEventListener('offline', checkNetworkStatus);

function initializeMap() {
  if (!L.Control.Geocoder) {
    console.error('Geocoder library not loaded.');
    return;
  }

  const redIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/supremindset/PAKAR/refs/heads/main/redPin.svg',
    iconSize: [100, 100],
    iconAnchor: [30, 100],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28]
  });

  const yellowIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/supremindset/PAKAR/refs/heads/main/yellowPin.svg',
    iconSize: [100, 100],
    iconAnchor: [30, 100],
    popupAnchor: [1, -34],
    tooltipAnchor: [16, -28]
  });

  const defaultLocation = [2.8126, 101.5018];
  const map = L.map('map').setView(defaultLocation, 19);

  const esriLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles &copy; <a href="https://www.esri.com/">Esri</a>',
    maxZoom: 19
  }).addTo(map);

  const hereSatelliteLayer = L.tileLayer('https://{s}.aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/satellite.day/{z}/{x}/{y}/256/png8?apiKey=ZrGsYcNXW4T_cGxQWLiIZ0DdraWLJ2XaCfI8axrRCkw&lg=eng', {
    attribution: 'Map data © 2024 HERE',
    subdomains: '1234',
    maxZoom: 22
  });

  const hereNormalDayLayer = L.tileLayer('https://{s}.base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day/{z}/{x}/{y}/256/png8?apiKey=ZrGsYcNXW4T_cGxQWLiIZ0DdraWLJ2XaCfI8axrRCkw&lg=eng', {
    attribution: 'Map data © 2024 HERE',
    subdomains: '1234',
    maxZoom: 20
  });

  const openStreetMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Map data © OpenStreetMap contributors',
    maxZoom: 19
  });

  const baseMaps = {
    "Esri World Imagery": esriLayer,
    "HERE Satellite": hereSatelliteLayer,
    "HERE Normal Day": hereNormalDayLayer,
    "OpenStreetMap": openStreetMapLayer
  };

  L.control.layers(baseMaps).addTo(map);

  const kaabahLatLng = [21.4225, 39.8262];
  firstPin = L.marker(defaultLocation, {icon: redIcon, draggable: true}).addTo(map);
  secondPin = L.marker([3.1390, 101.6869], {icon: yellowIcon, draggable: true}).addTo(map);

  // Create the shadow line object
  const shadowLine = L.polyline([[0, 0], [0, 0]], {
    color: 'green',
    weight: 10,
    opacity: 0.5,
    dashArray: '5, 5',
    lineCap: 'round',
    lineJoin: 'round'
  }).addTo(map);

  const initialPath = interpolateGreatCircle(2.8126, 101.5018, kaabahLatLng[0], kaabahLatLng[1], 100);
  const lineToKaabah = L.polyline(initialPath, {color: 'red'}).addTo(map);
  const lineBetweenPins = L.polyline([[2.8126, 101.5018], [3.1390, 101.6869]], {color: 'yellow'}).addTo(map);

  // Create and append the round button
const roundButton = document.createElement('button');
roundButton.className = 'round-button';
roundButton.id = 'newRoundButton';
roundButton.innerText = 'OK'; // Add text or any content
document.querySelector('.leaflet-map-pane').appendChild(roundButton);

// Prevent map clicks when the button is clicked
roundButton.addEventListener('click', (event) => {
  event.stopPropagation(); // This prevents the click from affecting the map
  console.log('Round button clicked'); // You can add other actions here

  // Scroll to the install-banner-container
  const bannerContainer = document.getElementById('install-banner-container');
  if (bannerContainer) {
    bannerContainer.scrollIntoView({ behavior: 'smooth' });
  }
});

// Function to update button position
function updateButtonPosition() {
  const firstPinLatLng = firstPin.getLatLng();
  const point = map.latLngToLayerPoint(firstPinLatLng);

  roundButton.style.left = `${point.x + 20}px`;
  roundButton.style.top = `${point.y - 60}px`; // Adjust this value for vertical positioning
}

  // Set initial position
  updateButtonPosition();

  // Update button position on drag
  firstPin.on('drag', updateButtonPosition);
  firstPin.on('dragend', function() {
    updateBearingAndLines('firstPin');
    lineToKaabah.setStyle({opacity: 1});
    updateButtonPosition();
  });

  // Hide specific lines when dragging starts
  firstPin.on('dragstart', function() {
    lineToKaabah.setStyle({opacity: 0});
  });

  secondPin.on('dragstart', function() {
    lineBetweenPins.setStyle({opacity: 0});
  });

  // Show lines and update positions when dragging ends
  secondPin.on('dragend', function() {
    updateBearingAndLines('secondPin');
    lineBetweenPins.setStyle({opacity: 1});
  });

  map.on('click', function(e) {
    secondPin.setLatLng(e.latlng);
    updateBearingAndLines('secondPin');
  });

  map.on('contextmenu', function(e) {
    firstPin.setLatLng(e.latlng);
    updateBearingAndLines('firstPin');
    updateButtonPosition();
  });

  L.Control.geocoder({
    defaultMarkGeocode: false
  })
  .on('markgeocode', function(e) {
    const bbox = e.geocode.bbox;
    const poly = L.polygon([
      bbox.getSouthEast(),
      bbox.getNorthEast(),
      bbox.getNorthWest(),
      bbox.getSouthWest()
    ]).addTo(map);
    map.fitBounds(poly.getBounds());
    firstPin.setLatLng(e.geocode.center);
    updateBearingAndLines('firstPin');
    updateButtonPosition();
  })
  .addTo(map);

  function updateLocation() {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        function(position) {
          const userLat = position.coords.latitude;
          const userLng = position.coords.longitude;
          const zoomLevel = 19; // Set your desired zoom level here

          firstPin.setLatLng([userLat, userLng]);
          map.setView([userLat, userLng], zoomLevel); // Update the view with the new location and zoom level
          updateBearingAndLines('firstPin');
          updateButtonPosition();
        },
        function() {
          alert('Unable to retrieve your location. Please enable location services.');
          firstPin.setLatLng(defaultLocation);
          map.setView(defaultLocation, 19); // Reset to default location with default zoom level
          updateBearingAndLines('firstPin');
          updateButtonPosition();
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    } else {
      alert('Geolocation is not supported by this browser.');
      firstPin.setLatLng(defaultLocation);
      map.setView(defaultLocation, 19); // Reset to default location with default zoom level
      updateBearingAndLines('firstPin');
      updateButtonPosition();
    }
  }

  const updateLocationButton = document.getElementById('updateLocationButton');
  updateLocationButton.addEventListener('click', updateLocation);

  const centerDotButton = document.getElementById('centerDotButton');
  centerDotButton.addEventListener('click', updateLocation);

  const markerTooltipText1Element = document.getElementById('markerTooltipText1');
  const markerTooltipText2Element = document.getElementById('markerTooltipText2');

  updateBearingAndLines = function(changedPin) {
    if (firstPin && secondPin) {
      const firstLatLng = firstPin.getLatLng();
      const secondLatLng = secondPin.getLatLng();

      const pathToKaabah = interpolateGreatCircle(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1], 100);
      lineToKaabah.setLatLngs(pathToKaabah);

      lineBetweenPins.setLatLngs([firstLatLng, secondLatLng]);

      const bearingToKaabah = calculateBearing(firstLatLng.lat, firstLatLng.lng, kaabahLatLng[0], kaabahLatLng[1]);
      const bearingToSecondPin = calculateBearing(firstLatLng.lat, firstLatLng.lng, secondLatLng.lat, secondLatLng.lng);

      let sunAzimuth = updateSunAzimuth(firstLatLng);
      updateShadowLine(firstLatLng, sunAzimuth);

      const currentDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();

      // Update the tooltip container
      markerTooltipText1Element.innerHTML = `
          Qiblat: ${bearingToKaabah.toFixed(2)}°<br/>
          Red Pin - Sun Azimuth: ${sunAzimuth.toFixed(2)}°<br/>
      `;

      markerTooltipText2Element.innerHTML = `
          Yellow Pin - Bearing bangunan: ${bearingToSecondPin.toFixed(2)}°
      `;

      if (!ELEMENTS.dateTimeInput.value) {
          ELEMENTS.qiblatInput.value = bearingToKaabah.toFixed(2);
      }

      if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
          ELEMENTS.degreeInput.value = bearingToSecondPin.toFixed(2);
      } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
          ELEMENTS.degreeInput.value = sunAzimuth.toFixed(2);
      }

      updateArrow(ELEMENTS.blackArrowLine, sunAzimuth);
      updateArrow(ELEMENTS.blackArrowHead, sunAzimuth);

      updateCompassDisplay();
      updateAngles();
    }
  };

  function updateSunAzimuth(position) {
    const selectedDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();
    const sunPosition = SunCalc.getPosition(selectedDate, position.lat, position.lng);
    const azimuth = sunPosition.azimuth * 180 / Math.PI + 180;
    return azimuth;
  }

  function updateShadowLine(latLng, objectHeight) {
    const isNight = isSunDown(new Date(ELEMENTS.dateTimeInput.value || Date.now()), latLng.lat, latLng.lng);

    if (!isNight) {
      const shadowEndpoint = calculateShadowEndpoint(latLng, objectHeight);
      shadowLine.setLatLngs([[latLng.lat, latLng.lng], [shadowEndpoint.lat, shadowEndpoint.lng]]);
      shadowLine.setStyle({
        color: 'green',
        weight: 3,
        opacity: 1,
        dashArray: '1, 1',
        lineCap: 'round',
        lineJoin: 'round'
      });
    } else {
      shadowLine.setLatLngs([[0, 0], [0, 0]]);
    }
  }
  
  function calculateShadowEndpoint(startLatLng, objectHeight) {
    const selectedDate = ELEMENTS.dateTimeInput.value ? new Date(ELEMENTS.dateTimeInput.value) : new Date();
    const position = SunCalc.getPosition(selectedDate, startLatLng.lat, startLatLng.lng);

    const azimuth = position.azimuth;
    const altitude = position.altitude;

    const shadowLength = objectHeight / Math.tan(altitude);

    const earthRadius = 6371000;

    const angularDistance = shadowLength / earthRadius;
    const bearing = azimuth;

    const lat1 = toRadians(startLatLng.lat);
    const lon1 = toRadians(startLatLng.lng);

    const lat2 = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) +
        Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearing));
    const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(lat1),
        Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2));

    return L.latLng(toDegrees(lat2), toDegrees(lon2));
  }

  ELEMENTS.dateTimeInput.addEventListener('change', function() {
    if (typeof updateBearingAndLines === 'function') {
      updateBearingAndLines('firstPin');
      updateShadowLine(firstPin.getLatLng(), parseFloat(ELEMENTS.degreeInput.value) || 0);
    }
  });

  ELEMENTS.kaedahQiblat.addEventListener('change', () => {
    updateDirectionLabels();
    toggleDateTimeInputVisibility();
    updateBearingAndLines('firstPin');
    if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
      ELEMENTS.degreeInput.placeholder = "Bearing";
      ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
    } else if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
      ELEMENTS.degreeInput.placeholder = "Azimuth Matahari";
      ELEMENTS.qiblatInput.placeholder = "True North Qiblat";
    }
    updateCompassDisplay();
  });
}

function calculateAndLabelAngles(angleA, angleB) {
  angleA = (angleA + 360) % 360;
  angleB = (angleB + 360) % 360;

  const oppositeAngleB = (angleB + 180) % 360;
  const sector1 = (angleB - angleA + 360) % 360 <= 180 ? (angleB - angleA + 360) % 360 : (oppositeAngleB - angleA + 360) % 360;
  const sector2 = 180 - sector1;
  const sector3 = sector1;
  const sector4 = sector2;

  const radius = 60;
  drawSectorArc(100, 100, radius, 0, sector1, document.getElementById('sector1'), document.getElementById('label1'), sector1.toFixed(2));
  drawSectorArc(100, 100, radius, sector1, sector1 + sector2, document.getElementById('sector2'), document.getElementById('label2'), sector2.toFixed(2));
  drawSectorArc(100, 100, radius, sector1 + sector2, sector1 + sector2 + sector3, document.getElementById('sector3'), document.getElementById('label3'), sector3.toFixed(2));
  drawSectorArc(100, 100, radius, sector1 + sector2 + sector3, 360, document.getElementById('sector4'), document.getElementById('label4'), sector4.toFixed(2));
}

function drawSectorArc(cx, cy, radius, startAngle, endAngle, pathElement, labelElement, label) {
  const start = polarToCartesian(cx, cy, radius, endAngle);
  const end = polarToCartesian(cx, cy, radius, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

  const d = [
    "M", cx, cy,
    "L", start.x, start.y,
    "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y,
    "Z"
  ].join(" ");

  pathElement.setAttribute("d", d);

  const midAngle = startAngle + (endAngle - startAngle) / 2;
  const labelPos = polarToCartesian(cx, cy, radius / 1.5, midAngle);
  labelElement.setAttribute("x", labelPos.x);
  labelElement.setAttribute("y", labelPos.y);
  labelElement.textContent = `${label}°`;
}

function polarToCartesian(cx, cy, radius, angleInDegrees) {
  const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
  return {
    x: cx + (radius * Math.cos(angleInRadians)),
    y: cy + (radius * Math.sin(angleInRadians))
  };
}

function updateAngles() {
  const angleA = parseFloat(ELEMENTS.degreeInput.value) || 0;
  const angleB = parseFloat(ELEMENTS.qiblatInput.value) || 0;

  calculateAndLabelAngles(angleA, angleB);
}

function initializeDynamicAngleUpdates() {
  ELEMENTS.degreeInput.addEventListener('input', updateAngles);
  ELEMENTS.qiblatInput.addEventListener('input', updateAngles);

  if (firstPin && secondPin) {
    firstPin.on('drag', function() {
      updateBearingAndLines('firstPin');
    });
    secondPin.on('drag', function() {
      updateBearingAndLines('secondPin');
    });
  }
}

// Function to setup debounce behavior for inputs
function setupInputWithDebounce(inputElement) {
  inputElement.addEventListener('input', () => {
    clearTimeout(inputDebounceTimeout);
    inputDebounceTimeout = setTimeout(() => {
      finalizeInput(inputElement);
    }, 1000); // 1 seconds delay
  });

  inputElement.addEventListener('focus', () => {
    clearTimeout(inputDebounceTimeout); // Clear timeout on focus
  });

  inputElement.addEventListener('blur', () => {
    finalizeInput(inputElement); // Finalize immediately on blur
  });
}

// Function to handle input finalization
function finalizeInput(inputElement) {
  inputElement.blur();  // Remove focus to stop editing
  updateCompassDisplay(); // Ensure the display is updated with the final value
}

const ELEMENTS = {
  circle: document.getElementById('circle'),
  centerLine: document.getElementById('centerLine'),
  arrowLine: document.getElementById('arrowLine'),
  arrowHead: document.getElementById('arrowHead'),
  blackArrowLine: document.getElementById('blackArrowLine'),
  blackArrowHead: document.getElementById('blackArrowHead'),
  kaedahQiblat: document.getElementById('kaedahQiblat'),
  degreeInput: document.getElementById('degreeInput'),
  degreeTooltip: document.getElementById('degreeTooltip'),
  qiblatInput: document.getElementById('qiblatInput'),
  qiblatTooltip: document.getElementById('qiblatTooltip'),
  distanceToKaabah: document.getElementById('distanceToKaabah'),
  dateTimeInput: document.getElementById('dateTimeInput'),
  status: document.getElementById('status')
};

const DISPLAY = {
  BLOCK: 'block',
  NONE: 'none'
};

const QIBLAT_METHODS = {
  BANGUNAN: 'bangunan',
  BAYANG: 'bayang'
};

function toRadians(degrees) {
  return degrees * Math.PI / 180;
}

function toDegrees(radians) {
  return radians * 180 / Math.PI;
}

function calculateBearing(lat1, lon1, lat2, lon2) {
  var lat1Rad = toRadians(lat1);
  var lat2Rad = toRadians(lat2);
  var deltaLonRad = toRadians(lon2 - lon1);

  var y = Math.sin(deltaLonRad) * Math.cos(lat2Rad);
  var x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(deltaLonRad);

  var bearing = Math.atan2(y, x);
  return (toDegrees(bearing) + 360) % 360;
}

function interpolateGreatCircle(lat1, lon1, lat2, lon2, steps) {
  var points = [];
  var startLat = toRadians(lat1);
  var startLon = toRadians(lon1);
  var endLat = toRadians(lat2);
  var endLon = toRadians(lon2);

  var d = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((endLat - startLat) / 2), 2) +
      Math.cos(startLat) * Math.cos(endLat) * Math.pow(Math.sin((endLon - startLon) / 2), 2)));

  for (var i = 0; i <= steps; i++) {
    var f = i / steps;
    var A = Math.sin((1 - f) * d) / Math.sin(d);
    var B = Math.sin(f * d) / Math.sin(d);

    var x = A * Math.cos(startLat) * Math.cos(startLon) + B * Math.cos(endLat) * Math.cos(endLon);
    var y = A * Math.cos(startLat) * Math.sin(startLon) + B * Math.cos(endLat) * Math.sin(endLon);
    var z = A * Math.sin(startLat) + B * Math.sin(endLat);

    var newLat = Math.atan2(z, Math.sqrt(x * x + y * y));
    var newLon = Math.atan2(y, x);

    points.push([toDegrees(newLat), toDegrees(newLon)]);
  }

  return points;
}

const showTooltip = (tooltipElement) => {
  tooltipElement.style.visibility = 'visible';
  tooltipElement.style.opacity = '1';
};

const hideTooltip = (tooltipElement) => {
  tooltipElement.style.visibility = 'hidden';
  tooltipElement.style.opacity = '0';
};

const updateArrow = (element, degree) => {
  element.style.transform = `translateY(-50%) rotate(${degree}deg)`;
};

const updateDirectionLabels = () => {
  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
    document.querySelector('.label-north').textContent = 'S';
    document.querySelector('.label-south').textContent = 'N';
    document.querySelector('.label-east').textContent = 'W';
    document.querySelector('.label-west').textContent = 'E';
  } else {
    document.querySelector('.label-north').textContent = 'N';
    document.querySelector('.label-south').textContent = 'S';
    document.querySelector('.label-east').textContent = 'E';
    document.querySelector('.label-west').textContent = 'W';
  }
};

const updateCompassDisplay = () => {
  const degree = parseFloat(ELEMENTS.degreeInput.value) || 0;
  const inputQiblaDegree = parseFloat(ELEMENTS.qiblatInput.value) || 0;

  let finalQiblatDegree = inputQiblaDegree;

  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BANGUNAN) {
    finalQiblatDegree = (finalQiblatDegree + 180) % 360;
  }

  ELEMENTS.centerLine.style.transform = `translateY(-50%) rotate(${degree}deg)`;
  ELEMENTS.circle.style.transform = `rotate(${90 - degree}deg)`;

  updateArrow(ELEMENTS.blackArrowLine, degree);
  updateArrow(ELEMENTS.blackArrowHead, degree);
  updateArrow(ELEMENTS.arrowLine, finalQiblatDegree || 0);
  updateArrow(ELEMENTS.arrowHead, finalQiblatDegree || 0);
};

const toggleDateTimeInputVisibility = () => {
  if (ELEMENTS.kaedahQiblat.value === QIBLAT_METHODS.BAYANG) {
    ELEMENTS.dateTimeInput.style.display = DISPLAY.BLOCK;
  } else {
    ELEMENTS.dateTimeInput.style.display = DISPLAY.NONE;
  }
};

ELEMENTS.qiblatInput.addEventListener('input', () => {
  updateCompassDisplay();
  resetActivityTimer();
});

ELEMENTS.degreeInput.addEventListener('input', () => {
  updateCompassDisplay();
  resetActivityTimer();
});

// Reset the activity timer and make the circle non-sticky
function resetActivityTimer() {
  clearTimeout(activityTimeout);
  const circleWrapper = document.querySelector('.sticky-wrapper');
  circleWrapper.classList.add('non-sticky');
  activityTimeout = setTimeout(() => {
    circleWrapper.classList.remove('non-sticky');
  }, 1000);
}

const populateDegreeNumbers = () => {
  const radius = ELEMENTS.circle.offsetWidth / 2;
  const offset = 20;
  for (let i = 0; i < 360; i += 10) {
    const degreeNumber = document.createElement('div');
    degreeNumber.className = 'degree-number';
    degreeNumber.textContent = i;

    const angle = i * (Math.PI / 180);
    const x = radius + (radius + offset) * Math.cos(angle);
    const y = radius + (radius + offset) * Math.sin(angle);

    degreeNumber.style.left = `${x}px`;
    degreeNumber.style.top = `${y}px`;
    degreeNumber.style.transform = `translate(-50%, -50%) rotate(${i}deg)`;

    ELEMENTS.circle.appendChild(degreeNumber);
  }
};

// Function to toggle sticky class on the circle
function toggleStickyOnFocus(inputElement, circleWrapper) {
  inputElement.addEventListener('focus', () => {
    circleWrapper.classList.add('non-sticky');
    setTimeout(() => {
      inputElement.scrollIntoView({behavior: 'smooth', block: 'center'});
    }, 300);
  });

  inputElement.addEventListener('blur', () => {
    circleWrapper.classList.remove('non-sticky');
    resetActivityTimer(); // Ensure the timer is reset on blur
  });
}

// Function to toggle the map's circle class
function toggleMapCircle() {
  const mapElement = document.getElementById('map');
  const circleContainer = document.querySelector('.circle-container');

  if (circleContainer.contains(mapElement)) {
    // Move the map outside the circle and restore original styles
    document.querySelector('.map-fieldset').appendChild(mapElement);
    mapElement.style.borderRadius = '0'; // Remove circular shape
    mapElement.style.height = '50vh'; // Original height
    mapElement.style.width = '100%'; // Original width
    mapElement.style.position = 'relative'; // Reset position
    mapElement.style.top = ''; // Reset top
    mapElement.style.left = ''; // Reset left
  } else {
    // Move the map inside the circle and make it circular
    circleContainer.appendChild(mapElement);
    mapElement.classList.add('circle-map'); // Add the class for circular shape
    alignMapWithCircle(); // Align map size with circle
    mapElement.style.borderRadius = '50%'; // Make it circular
    mapElement.style.position = 'absolute'; // Position absolutely
    mapElement.style.top = '0'; // Align at top
    mapElement.style.left = '0'; // Align at left
  }
}

function alignMapWithCircle() {
  const mapElement = document.getElementById('map');
  const circleContainer = document.querySelector('.circle');

  mapElement.style.width = circleContainer.offsetWidth + 'px';
  mapElement.style.height = circleContainer.offsetHeight + 'px';
}

if (!isOnline()) {
  updateBearingAndLines = function() {
    console.warn("Offline mode: updateBearingAndLines cannot be executed.");
  };
}

// Function to initialize the degree adjustment buttons
function initializeDegreeButtons() {
  const increaseButton = document.getElementById('increaseButton');
  const decreaseButton = document.getElementById('decreaseButton');
  const rotationValue = document.getElementById('rotationValue');
  const mapElement = document.getElementById('map');

  increaseButton.addEventListener('mousedown', () => {
    speed = 1000; // Reset speed
    handleButtonHold(increaseDegree);
  });

  decreaseButton.addEventListener('mousedown', () => {
    speed = 1000; // Reset speed
    handleButtonHold(decreaseDegree);
  });

  document.addEventListener('mouseup', () => {
    clearInterval(holdInterval);
  });

  // For touch devices
  increaseButton.addEventListener('touchstart', (e) => {
    e.preventDefault();
    speed = 1000; // Reset speed
    handleButtonHold(increaseDegree);
  });

  decreaseButton.addEventListener('touchstart', (e) => {
    e.preventDefault();
    speed = 1000; // Reset speed
    handleButtonHold(decreaseDegree);
  });

  document.addEventListener('touchend', () => {
    clearInterval(holdInterval);
  });

  function updateRotation() {
    rotationValue.textContent = `${degree}°`;
    mapElement.style.transform = `rotate(${degree}deg)`;
  }

  function increaseDegree() {
    degree = (degree + 0.5) % 360;
    updateRotation();
  }

  function decreaseDegree() {
    degree = (degree - 0.5 + 360) % 360; // Ensure the value stays positive
    updateRotation();
  }

  function handleButtonHold(callback) {
    callback();
    holdInterval = setInterval(() => {
      callback();
      speed = Math.max(30, speed - 10000000); // Decrease interval time to speed up
      clearInterval(holdInterval); // Clear previous interval
      holdInterval = setInterval(callback, speed); // Set new faster interval
    }, speed);
  }
}

function showInstallPromotion() {
  if (deferredPrompt) {
    // Create a custom UI element (e.g., a banner or modal)
    const installBanner = document.createElement('div');
    installBanner.classList.add('install-banner');
    installBanner.textContent = 'Install this app on your device?';

    // Add a click event listener to the banner
    installBanner.addEventListener('click', () => {
      // Show the installation prompt
      deferredPrompt.prompt();
      // Wait for the user's response
      deferredPrompt.userChoice.then((choiceResult) => {
        if (choiceResult.outcome === 'accepted') {
          console.log('User accepted the install prompt');
        } else {
          console.log('User dismissed the install prompt');
        }
        // Remove the install banner
        installBanner.remove();
        // Reset the deferred prompt variable
        deferredPrompt = null;
      });
    });

    // Append the install banner to your UI
    document.body.appendChild(installBanner);
  }
}

window.addEventListener('beforeinstallprompt', (e) => {
  // Prevent the mini-infobar from appearing on mobile
  e.preventDefault();
  // Stash the event so it can be triggered later.
  deferredPrompt = e;
  // Update UI to notify the user they can install the PWA
  showInstallPromotion();
});

function isSunDown(date, latitude, longitude) {
  const sunTimes = SunCalc.getTimes(date, latitude, longitude);
  const currentTime = date.getTime();
  return currentTime < sunTimes.sunrise.getTime() || currentTime > sunTimes.sunset.getTime();
}
</script>
</body>
</html>
